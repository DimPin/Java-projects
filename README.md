# HomeWork 5

Джава - https://github.com/vyntyk/Srezy.git
Питон - https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5
Реализовать любой паттерн с лекции . Выпустить диаграмму компонент UML по нему.

#HomeWork 6
__
Задание: Переделка программы под чистую архитектуру
__
Вам предоставляется программа, которая представляет интернет-магазин книг с использованием коллекций. Ваша задача - переработать эту программу, применяя принципы чистой архитектуры для лучшей организации кода и разделения компонентов. В результате переработки программа должна следовать принципам Boundary-Control-Entity (BCE).
__
Требования:
__
Создайте пакеты domain, data, и presentation.
__
В пакете domain создайте классы, представляющие бизнес-объекты интернет-магазина книг. Например, Book - представляющий модель книги.
__
В пакете data создайте интерфейс BookRepository, определяющий методы для управления книгами в интернет-магазине. Затем реализуйте этот интерфейс в классе InMemoryBookRepository, используя коллекции для хранения данных о книгах.
__
В пакете presentation создайте класс Main, который будет представлять точку входа в приложение и обрабатывать пользовательские запросы.
__
Используйте принципы чистой архитектуры для организации компонентов (BCE). Каждый компонент должен быть отделен от других, взаимодействие должно происходить через абстракции, а не через конкретные реализации.
__
Перенесите функциональность работы с коллекциями и хранения данных в пакет data, таким образом, чтобы она не проникала в другие компоненты.
__
Обеспечьте возможность добавления, удаления и получения списка книг через интерфейс BookRepository, а затем используйте его в Main для управления книгами.
__
Убедитесь, что код программы чистый, читаемый и хорошо структурированный. Обеспечьте надлежащее разделение ответственности между компонентами и минимизируйте повторяющийся код.
__
Примечание:
Данный код предоставлен только для ознакомления с исходной реализацией и не представляет полный функционал интернет-магазина книг. Ваша задача - переработать его согласно принципам чистой архитектуры и обеспечить соответствующий функционал.
__

**
Вот пример кода, представляющего интернет-магазин книг с использованием коллекций, но без реализации чистой архитектуры:
**


import java.util.ArrayList;
import java.util.List;

// Класс представляющий книгу
class Book {
    private String id;
    private String title;
    private String author;
    private double price;

    // Конструктор, геттеры и сеттеры
}

// Класс, реализующий хранилище книг с использованием коллекций
class BookStore {
    private List<Book> books;

    public BookStore() {
        books = new ArrayList<>();
    }

    public void addBook(Book book) {
        books.add(book);
    }

    public void removeBook(Book book) {
        books.remove(book);
    }

    public List<Book> getAllBooks() {
        return books;
    }
}

public class Main {
    public static void main(String[] args) {
        BookStore bookStore = new BookStore();

        // Добавляем книги в магазин
        Book book1 = new Book("1", "Clean Code", "Robert C. Martin", 34.99);
        Book book2 = new Book("2", "Effective Java", "Joshua Bloch", 29.99);
        bookStore.addBook(book1);
        bookStore.addBook(book2);

        // Получаем список всех книг в магазине
        List<Book> allBooks = bookStore.getAllBooks();
        for (Book book : allBooks) {
            System.out.println("Книга: " + book.getTitle() + ", Автор: " + book.getAuthor() + ", Цена: $" + book.getPrice());
        }
    }
}

# HomeWork 10

Домашнее задание: Реализация паттернов Агрегатор, Репозиторий и Кеширования
Цель: Освоить принципы работы и применение трёх ключевых паттернов проектирования: Агрегатор, Репозиторий и Кеширование.

Часть 1: Паттерн Агрегатор
    Реализуйте классы Order, OrderItem и Product.
    Order должен содержать список OrderItem, каждый из которых содержит Product и количество этого продукта.
    У каждого заказа должен быть метод для расчета общей стоимости.
    
Часть 2: Паттерн Репозиторий
    Создайте интерфейс OrderRepository, который определяет методы для работы с заказами (сохранение, загрузка по ID, загрузка всех заказов и т. д.).
    Реализуйте класс OrderRepositoryImpl, который реализует данный интерфейс, используя любую базу данных на ваш выбор (может быть встроенной, например, SQLite).
    В репозитории обеспечьте сохранение и загрузку заказов, а также всех связанных с ними объектов (OrderItem, Product).
    
Часть 3: Паттерн Кеширования
    Исследуйте и выберите одну из библиотек для кеширования в Java (например, EhCache, Caffeine или Guava Cache).
    Реализуйте кеширование в вашем репозитории таким образом, чтобы часто запрашиваемые заказы загружались из кэша, а не из базы данных.
    Обеспечьте инвалидацию кэша (обновление данных в кэше), если информация в базе данных была изменена.
    
Дополнительное задание:
    Реализуйте пользовательский интерфейс (может быть консольным или графическим), чтобы демонстрировать создание, редактирование, загрузку и удаление заказов.
    Добавьте возможность фильтрации и сортировки заказов при их загрузке из базы данных.

Советы:

Соблюдайте принципы SOLID при проектировании и реализации вашего приложения.
Обрабатывайте все возможные исключения, особенно при работе с базой данных.
Подумайте над оптимальной стратегией кеширования в зависимости от предполагаемого объема данных и частоты запросов.

Это задание предполагает разработку приложения с использованием трёх ключевых паттернов
